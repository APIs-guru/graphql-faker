"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const test_1 = require("@oclif/test");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const cmd = require("../src");
// https://github.com/apollographql/apollo-tooling/blob/e8d432654ea840b9d59bf1f22a9bc37cf50cf800/packages/apollo/src/commands/client/__tests__/generate.test.ts
const deleteFolderRecursive = (path) => {
    if (fs_1.default.existsSync(path)) {
        fs_1.default.readdirSync(path).forEach(function (file) {
            const curPath = path + "/" + file;
            if (fs_1.default.lstatSync(curPath).isDirectory()) {
                // recurse
                deleteFolderRecursive(curPath);
            }
            else {
                // delete file
                fs_1.default.unlinkSync(curPath);
            }
        });
        fs_1.default.rmdirSync(path);
    }
};
const makeNestedDir = (dir) => {
    if (fs_1.default.existsSync(dir))
        return;
    try {
        fs_1.default.mkdirSync(dir);
    }
    catch (err) {
        if (err.code === "ENOENT") {
            makeNestedDir(path_1.default.dirname(dir)); //create parent dir
            makeNestedDir(dir); //create dir
        }
    }
};
const setupFS = (files) => {
    let dir;
    return {
        async run() {
            // make a random temp dir & chdir into it
            dir = fs_1.default.mkdtempSync("__tmp__");
            process.chdir(dir);
            // fill the dir with `files`
            Object.keys(files).forEach(key => {
                if (key.includes("/"))
                    makeNestedDir(path_1.default.dirname(key));
                fs_1.default.writeFileSync(key, files[key]);
            });
        },
        finally() {
            process.chdir("../");
            deleteFolderRecursive(dir);
        }
    };
};
// helper function to resolve files from the actual filesystem
const resolveFiles = (opts) => {
    let files = {};
    Object.keys(opts).map(key => {
        files[key] = fs_1.default.readFileSync(path_1.default.resolve(__dirname, opts[key]), {
            encoding: "utf-8"
        });
    });
    return files;
};
describe("graphql-json-to-sdl given a valid GraphQL schema as JSON", () => {
    test_1.test
        .register("fs", setupFS)
        .fs(resolveFiles({
        "./schema.json": "../__fixtures__/schema.json"
    }))
        .do(() => cmd.run(["./schema.json", "./schema.graphql"]))
        .it("writes the GraphQL schema in SDL to a file", () => {
        expect(fs_1.default.readFileSync("./schema.graphql").toString()).toMatchSnapshot();
    });
});
describe("graphql-json-to-sdl given schemas with the same types and fields in a different order", () => {
    const schema = fs_1.default.readFileSync(path_1.default.resolve(__dirname, "../__fixtures__/schema.json"), "utf-8");
    const { data } = JSON.parse(schema);
    data.__schema.types.reverse();
    data.__schema.types.forEach((type) => {
        if (!type.fields)
            return;
        type.fields.reverse();
    });
    const reversedSchema = JSON.stringify({ data });
    test_1.test
        .register("fs", setupFS)
        .fs({
        "./schema.json": schema,
        "./reversedSchema.json": reversedSchema
    })
        .do(() => cmd.run(["./schema.json", "./schemaOne.graphql"]))
        .do(() => cmd.run(["./reversedSchema.json", "./schemaTwo.graphql"]))
        .it("produces the same output", () => {
        const schemaOne = fs_1.default.readFileSync("./schemaOne.graphql").toString();
        const schemaTwo = fs_1.default.readFileSync("./schemaTwo.graphql").toString();
        expect(schemaOne).toBeTruthy();
        expect(schemaTwo).toBeTruthy();
        expect(schemaOne).toBe(schemaTwo);
    });
});
describe("graphql-json-to-sdl given no arguments", () => {
    test_1.test
        .do(() => cmd.run([]))
        .catch(error => expect(error.message).toMatch(/Missing 2 required args/))
        .it("writes to stderr");
    test_1.test
        .do(() => cmd.run([]))
        .exit(2)
        .it("exits with a status of 2");
});
describe("graphql-json-to-sdl given one argument", () => {
    test_1.test
        .do(() => cmd.run(["./schema.json"]))
        .catch(error => expect(error.message).toMatch(/Missing 1 required arg/))
        .it("writes to stderr");
    test_1.test
        .do(() => cmd.run(["./schema.json"]))
        .exit(2)
        .it("exits with a status of 2");
});
describe("graphql-json-to-sdl given an empty JSON GraphQL schema", () => {
    test_1.test
        .register("fs", setupFS)
        .fs({
        "./emptySchema.json": ""
    })
        .do(() => cmd.run(["./emptySchema.json", "./schema.graphql"]))
        .catch(error => expect(error.message).toMatch(/Schema file .\/emptySchema.json is empty/))
        .it("writes to stderr");
    test_1.test
        .register("fs", setupFS)
        .fs({
        "./emptySchema.json": ""
    })
        .do(() => cmd.run(["./emptySchema.json", "./schema.graphql"]))
        .exit(1)
        .it("exits with a status of 1");
});
describe("graphql-json-to-sdl given a file that doesn't exist", () => {
    test_1.test
        .do(() => cmd.run(["./missingSchema.json", "./schema.graphql"]))
        .catch(error => expect(error.message).toMatch(/ENOENT: no such file or directory, open '.\/missingSchema.json'/))
        .it("writes to stderr");
    test_1.test
        .do(() => cmd.run(["./missingSchema.json", "./schema.graphql"]))
        .exit(1)
        .it("exits with a status of 1");
});
